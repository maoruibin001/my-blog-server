# go语言简单入门--并发 

系统调用过程中的CPU状态切换和流程控制

1、用户空间：

用户进程中的程序 ->发出系统调用->封装例程

||

2、内核空间（CPU状态切换  用户态=>内核态）

系统调用处理程序->系统调用服务例程->系统调用处理程序

||

3、用户空间（CPU状态切换 内核态=》用户态）

封装例程->用户进程中的程序。

封装例程语系统调用时一一对应的，实际上他就是我们所说的内核暴露给用户编程的接口。另外，系统调用处理程序和系统调用服务例程可以看做是内核为了响应用户进程的系统调用而执行的一系列函数，前面将其统称为内核函数。！！只有当CPU切换至内核态之后，才可以执行内核空间中的函数，而在内核函数执行完毕后，CPU状态也会被及时切换回用户态



go线程实现模型（M、P、G）

M:machine的缩写，一个M代表一个内核线程或称工作线程

P：processor的缩写，一个P代表g代码片段执行所需要的必要资源（或称上下文环境）

G：goroutine的缩写，一个G代表一个go的代码片段。前者是对后者的一种封装。



go语言实现并发采用的线程模型是类似于两级线程模型。即一部分由操作系统内核承担，一部分由go的调度器承担。调度器主要的工作就是对M、P、G进行管理。

附上一张调度器的工作流程图：



